## 百度电话一面/11.13号晚上六点半
什么时候可以来实习，可以实习多久
学校的课程怎么办？
自我介绍


c/c++内存模型


怎么解决大量频繁的内存申请释放


答：利用池化技术。可以构建一块内存池，在模仿STL里面的空间配置器，将内存申请利用内存池的自由链表数组来管理不同大小的内存块，完成内存的申请和释放，
不用频繁的向系统去申请，少调用系统级别的函数。调用一次virtual Alloc以页的方式申请，挂载在自由链表数组上，以后的申请与释放直接从链表数组中获取即可，提高效率。
不用频繁的去在堆中找合适的空间进行内存的申请。

生产者消费者模型？STL队列？优先级队列？堆？如何调整堆？

答： 生产者消费者模型 是为了解决生产者和消费者 之间的关系而提出的。
在生产者 和消费者模型中，举一个抓包的例子，如果生产者生产大量的数据填满消费者的缓冲区，消费者处理不及时，就会丢包。 缓冲区溢出，也会丢失大量的数据报。所以
生产者和消费者之间的耦合度太大了。所以提出了生产者消费者模型。 中间加了一层 缓冲区队列。

就是普通的队列。 不是优先级队列。 堆的向下调整法，从第一个非叶子节点开始向下逐层的调整堆。

建堆的时间复杂度为 O(N) 

如果有大量数据放入有序队列，怎么快速查找


答：
1) 二分：O(lgN)
2) 使用跳表快速定位答案 期望值O(lgN)

首先跳表是有序的，是可以进行范围查找的数据结构。跳表的平均查找和插入时间复杂度都是O(lgn)
首先是维护了 一个多层次的链表，且每一层链表中的元素都是下一层链表中元素的子集。一开始
算法从最稀疏的层次开始搜索，直至查询到的元素在两个相邻元素之间的时候，将快表跳转到下一个层次进行
搜索。
可以在每两个结点提取一个结点建立索引，我们把抽取出来的结点叫做索引层或者索引，down 表示指向原始链表结点的指针。



在哪里用到过生产者消费者模型？说了畅聊系统项目，开始无限聊项目



数据池？基于生产者消费者模型实现？多线程？线程安全怎么实现？



为什么用UDP通信不同TCP？UDP相比于TCP的优势？

答：UDP速度快(时延低)、操作简单、要求系统资源较少,由于通讯不需要连接,可以实现广播发送

随着网络技术的不断发展，网速已经不再是传输的瓶颈，UDP协议以其简单，传输快的优势，在越来越多
的场景下 取代了TCP
原因：1) 网络环境变好，网络传输的延迟、稳定性也随之改善，UDP的丢包率低于5%，如果再使用应用层重传，能够完全确保传输的可靠性。
	  2) HTTP2.0 是基于 QUICKUDP的， 
	  3) TCP的机制使用了复杂的拥塞控制算法，建立了繁琐的握手过程以及重传策略，在内置的协议栈中很难被改变
	  
如果有百万个客户端，服务端如何处理应对？


epoll如何处理高并发，相比poll有什么优势

答：epoll的回调函数：
	
	acceptCallBack、readCallBack、 writeCallBack 、 ，， ，，
	描述符连接回调  读操作的回调   写操作的回调  
	
	用户层事件轮询结构体：
	typedef struct EventLoop
	{
		int maxfd; 	  // 最大描述符
		int setsize;  // 监听
		FIleEvent * events; // 事件通用结构体 里面有绑定的回调函数
		
	}EventLoop;
	最终用户态： 轮询处理所有epoll就绪事件，并且调用之前注册好的回调函数
	


服务端的多线程是怎么实现的？怎么处理客户端的连接到来和数据通信？

如何让这个线程数量可控，可以有效的处理客户端的连接和数据通信？

客户端和服务端之间设想一个阻塞缓冲，大量客户端连接到来，服务端从阻塞缓冲中取怎么高效处理？


像Redis模型一样，采用异步非阻塞的模式来接收数据。
netty 是运用Hadoop的RPC框架实现的一种  异步非阻塞，实时，高效率的方式处理连接线程。
1. 创建服务端线程 设置为非阻塞模式。
2. 绑定监听，配置参数，backlog参数的大小
3. 创建一个独立的IO线程，用于多路复用器的查询，看是缓冲区中是否否有线程到啦。
4. 启用IO线程，进行数据的IO操作，建立连接等等。 

多进程、多线程？线程池？


问了部门：短视频研发部，php\go后端研发(主要还是php,正在向go转型 )，说了百度的实习薪资还是很不错的
有什么想问他的？
一面面试官很干脆，说我这里过了，你等二面吧
5分钟后二面面试官电话过来约时间


##百度电话二面/11.16号晚上八点
自我介绍
又是和一面一样无限说畅聊项目
五种IO模型，epoll是同步的还是异步的，阻塞还是非阻塞
epoll实现原理，如何实现高并发的
进程和线程的区别
进程和线程的优点缺点
问了学校的课程，学了哪些
MySQL事务、特性
事务回滚的实现
MySQL索引
B+树性质，和二叉树有什么区别
聚集索引和非聚集索引
MySQL存储引擎
UDP和TCP的区别以及应用场景
TCP通过什么机制来保证可靠传输
https相比http的区别，对称加密和非对称加密
场景题：用什么数据结构实现网页的前进后退功能
场景题：找出一个数组中前10个最大的，我说了TOPK问题，面试官笑了说，原来你会这个啊
LRU
聊搜索引擎项目，重点说正排索引、倒排索引
平时都是怎么学习的，在什么地方学习的这些知识
什么时候可以去实习，学校的课程
有什么想问他的
记起来的大概就是这些吧


##百度电话三面/11.17号下午两点

无限聊搜索引擎项目，问的特别细
无限聊畅聊系统项目，问的特别细

进程、线程的区别

线程的共享与独有

线程安全：互斥锁、条件变量

生产者消费者模型：push、pop函数详细流程 ！！！！！！！！

TCP三次握手详细过程，为什么是三次，不是二次四次

MySQL了解多少，在哪里用到过



算法题：二分查找？时间复杂度？如果有重复的，要求找到重复的第一个

哈希冲突

哈希函数知道哪些 

有什么想问他的？
让我电话保持畅通，接下来会有技术经理面我


##百度电话四面/11.17号下午四点左右
先给我来了一道算法题：
N个数组，每个数组有M个元素且是有序的，怎么找到最小的前10个元素，要求时间复杂度小于O(N)
然后就是很严肃的问问题
个人优缺点：我又嘴欠说了算法OJ不好
leetCode刷了多少题
家庭情况
考研
个人学习成绩
在学校专业排多少名
又是问学校的课程，学校让我们去实习吗？
可以想起来的大概就这些吧，反正都是HR那些套路感觉
最后说有什么想问他的，让我等通知

##百度HR小姐姐电话/11.19号晚上8点多，我正在洗澡，面试期间手机随时带着不静音
问我最快啥时候能到岗，说一些薪资福利，然后加了微信慢慢聊。。。


将套接字设置为阻塞：

用以下方法将socket设置为非阻塞方式 

int flags = fcntl(socket, F_GETFL, 0); 
fcntl(socket, F_SETFL, flags | O_NONBLOCK);



应用层实现采用 超时重传，实现udp的可靠传输

在规定的时间内，若没有收到send to的信息，我们就认为数据报丢失，需要打破recvfrom的阻塞等待，
设置一个闹钟定时器alarm,当收到SIGALRM信号时，程序中断，转去处理中断响应函数，通知客户端进行重传

从调用该函数开始，seconds秒之后向进程发送一个SIGALRM信号


但是还有一个容易被人忽视的问题：在Linux中，默认处理中断的方式是：
当从中断调用返回时，继续执行被中断的系统调用（用在刚才说的例子上就是：继续redvfrom……）

就不能单纯的用signal函数去设置中断处理程序了，而是要用另一个函数：sigaction
igaction可以自己设置是否重启动函数，即上面例子中的alrmact.sa_flags = SA_NOMASK选项，
SA_NOMASK为不重启动，中断已阻塞的函数recvfrom，使程序继续往下执行


三次握手可以携带数据吗?

第一次和第二次是不可以携带数据的，但是第三次是可以携带数据的。

加入第一次，第二次可恶意携带数据的话，那么对于服务器是不是太危险了。
如果有人恶意攻击服务器，每一次都接收大量的数据。对于频繁的SYN报文发送，
服务器会花费很多时间和内存空间去接收这些报文。
TCP第三次ACK的时候都已经建立连接了，所以就可以发送数据了。


ThreadCache 

void Allocte(size_t size)
{
	size_t index = SizeClass::ListIndex(size); // 根据对象大小 算出自由链表的下标
	FreeList& freeList = _freeLists[index];
	if(!empty())
	{
		return freeList.Pop();
	}
	else
	{
		return FetchFromCentralCache(SizeClass::RoundUp(size));
	}
}
ListIndex(size_t size)
{
	int group_array[4] = {16,56,56,56};
	
	16-128    // 以8字节为跨度进行对齐   区间长度 16
	128-1024  // 以16字节为跨度对齐				  56
	1024-8192 // 以128字节为跨度进行对齐		  56
	8192-65535// 以1024字节为跨度进行对齐         56
}


size_t NumMoveSize(size_t size) // 看申请多少个size大的对象
{
	if(size == 0)
		return 0;
	int num = MAX_SIZE / size;
	控制num 在[2,512]个之间
}

size_t NumMovePage(size_t size) // 看申请多少页的Page
{
	size_t num = NumMoveSize(size); // 先计算申请多少个size 给链表
	size_t npage = num* size; // 算出要申请的多少内存。 
	
	npage >>= 12; // 内存 / 4k 得到 申请多少物理页
	if(npage == 0)
		npage = 1;
	return npage;
	
}

